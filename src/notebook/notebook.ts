import * as vscode from 'vscode';
import { Packageable } from '../packageable';
import { Workspace } from '../workspace/workspaceClass';
import { Timed } from '../timedView';
import { disable, update, notebookDecorations } from './timedViewUpdate';
import { v4 as uuidv4 } from 'uuid';
import { editNote,  addNote, removeNote, writeSingleNote, readNotebook } from './updateNoteContents';
import { Buff } from '../Buffer/bufferSource';
import { Renamable } from '../recyclingBin/recyclingBinView';
import { TabLabels } from '../tabLabels/tabLabels';
import { compareFsPath, defaultProgress, formatFsPathForCompare } from '../miscTools/help';
import { grepExtensionDirectory } from '../miscTools/grepExtensionDirectory';

export interface Note {
    kind: 'note';
    noteId: string;
    noun: string;
    appearance: string[];
    aliases: string[];
    description: string[];
    uri: vscode.Uri;
}

export interface AppearanceContainer {
    kind: 'appearanceContainer';
    noteId: string;
    appearances: SubNote[];
}

export interface SubNote {
    kind: 'description' | 'appearance';
    idx: number;
    noteId: string;
    description: string;
}

export interface NoteMatch {
    range: vscode.Range;
    note: Note;
}


export class Notebook 
implements 
    vscode.TreeDataProvider<Note | SubNote | AppearanceContainer>, 
    vscode.HoverProvider, Timed, Renamable<Note>,
    vscode.ReferenceProvider
{
    writeSingleNote = writeSingleNote;
    readNotebook = readNotebook;
    addNote = addNote;
    removeNote = removeNote;
    editNote = editNote;

    enabled: boolean;
    update = update;
    disable = disable;

    static singleton: Notebook;

    public matchedNotebook: { [index: string]: NoteMatch[] };
    protected nounsRegex: RegExp | undefined;

    protected notebook: Note[];
    protected notebookFolderPath: vscode.Uri;
    public view: vscode.TreeView<Note | SubNote | AppearanceContainer>;
    constructor (
        public workspace: Workspace,
        public context: vscode.ExtensionContext
    ) {
        this.notebookFolderPath = workspace.notebookFolder;
        
        this.matchedNotebook = {};

        // Will be modified by TimedView
        this.enabled = true;

        // Read notebook from disk
        this.notebook = []; 
        this.view = {} as vscode.TreeView<Note | SubNote | AppearanceContainer>
        this._onDidChangeFile = new vscode.EventEmitter<vscode.FileChangeEvent[]>();
        Notebook.singleton = this;

        this.context.subscriptions.push(notebookDecorations);
    }

    async renameResource (node?: Note | undefined): Promise<void> {
        if (!node) return;
        
        const originalName = node.noun;
        const newName = await vscode.window.showInputBox({
            placeHolder: originalName,
            prompt: `What would you like to rename note for '${originalName}'?`,
            ignoreFocusOut: false,
            value: originalName,
            valueSelection: [0, originalName.length]
        });
        if (!newName) return;

        node.noun = newName;
        this.writeSingleNote(node);
        return this.refresh().then(() => {
            TabLabels.assignNamesForOpenTabs();
        });
    }

    async initialize () {
        this.notebook = await this.readNotebook();
        this.nounsRegex = this.getNounsRegex();
        this.view = vscode.window.createTreeView(`wt.notebook.tree`, {
            treeDataProvider: this,
            canSelectMany: true,
            showCollapseAll: true,
        });
        this.context.subscriptions.push(this.view);
        this.context.subscriptions.push(vscode.languages.registerHoverProvider({
            language: 'wt',
        }, this));
        this.context.subscriptions.push(vscode.languages.registerHoverProvider({
            language: 'wtNote',
        }, this));

        this.context.subscriptions.push(vscode.languages.registerDefinitionProvider({
            language: 'wt',
        }, this));
        this.context.subscriptions.push(vscode.languages.registerDefinitionProvider({
            language: 'wtNote',
        }, this));

        this.context.subscriptions.push(vscode.languages.registerReferenceProvider({
            language: "wt",
        }, this));
        this.context.subscriptions.push(vscode.languages.registerReferenceProvider({
            language: "wtNote",
        }, this));

        this.registerCommands();
    }

    static getNewNoteId (): string {
        // Default id generated by 'uuid' cannot be used as a capture group name,
        //      so we need to map them to something usable
        const id = uuidv4();
        //@ts-ignore
        const mappedId = id.replaceAll('-', '');            // remove dashes
        return `a${mappedId}`;                              // add an 'a' to the beginning
    }

	public _onDidChangeFile: vscode.EventEmitter<vscode.FileChangeEvent[]>;
	get onDidChangeFile(): vscode.Event<vscode.FileChangeEvent[]> {
		return this._onDidChangeFile.event;
	}

	private _onDidChangeTreeData: vscode.EventEmitter<Note | SubNote | AppearanceContainer | undefined> = new vscode.EventEmitter<Note | SubNote | AppearanceContainer | undefined>();
	readonly onDidChangeTreeData: vscode.Event<Note | SubNote | AppearanceContainer | undefined> = this._onDidChangeTreeData.event;
	async refresh (reload: boolean = false) {
        if (reload) {
            this.notebook = await this.readNotebook();
        }
        // Also update the nouns regex
        this.nounsRegex = this.getNounsRegex();
		this._onDidChangeTreeData.fire(undefined);
	}

    protected getNounPattern (note: Note, withId: boolean = true) {
        const realAliases = note.aliases
            .map(a => a.trim())
            .filter(a => a.length > 0);

        const aliasesAddition = realAliases.length > 0 
            ? `|${realAliases.join('|')}`
            : ``;
        const idAddition = withId
            ? `?<${note.noteId}>`
            : ``;
        return `(${idAddition}${note.noun}${aliasesAddition})`
    }

    private getNounsRegex (withId: boolean=true, withSeparator: boolean=true, subset?: Note[]): RegExp {
        if (this.notebook.length === 0) {
            return /^_^/
        }
        const nounFragments = (subset || this.notebook).map(note => this.getNounPattern(note, withId))
        const regexString = withSeparator 
            ? '(^|[^a-zA-Z0-9])?' + `(${nounFragments.join('|')})` + '([^a-zA-Z0-9]|$)?'
            : `(${nounFragments.join('|')})`;
        const nounsRegex = new RegExp(regexString, 'gi');
        return nounsRegex;
    }

    private registerCommands () {

        const doTheThingAndWrite = async (f: () => Promise<string | null>) => {
            const result = await f();
            if (result === null) return;
            const noteId = result;

            const note = this.notebook.find(note => note.noteId === noteId);
            if (note === undefined) return;
            this.writeSingleNote(note);
        }
        this.context.subscriptions.push(vscode.commands.registerCommand("wt.notebook.addNote", (resource: Note | undefined) => { doTheThingAndWrite(() => this.addNote(resource)) }));
        this.context.subscriptions.push(vscode.commands.registerCommand("wt.notebook.removeNote", (resource: Note) => { doTheThingAndWrite(() => this.removeNote(resource)) }));
        this.context.subscriptions.push(vscode.commands.registerCommand('wt.notebook.search', (resource: Note) => { this.searchInSearchPanel(resource) }));
        this.context.subscriptions.push(vscode.commands.registerCommand('wt.notebook.editNote', (resource: Note | AppearanceContainer | SubNote) => { this.editNote(resource) }));
        this.context.subscriptions.push(vscode.commands.registerCommand('wt.notebook.getNotebook', () => this));
        this.context.subscriptions.push(vscode.commands.registerCommand('wt.notebook.refresh', () => {
            return this.refresh(true);
        }));
    }

    getTreeItem(noteNode: Note | SubNote | AppearanceContainer): vscode.TreeItem {
        const editCommand: vscode.Command = {
            command: "wt.notebook.editNote",
            title: "Edit Note",
            arguments: [ noteNode ],
        };
        switch (noteNode.kind) {
            case 'note': 
                const aliasesString = noteNode.aliases.join(', ');
                return {
                    id: noteNode.noteId,
                    contextValue: 'note',
                    label: noteNode.noun,
                    description: aliasesString,
                    collapsibleState: vscode.TreeItemCollapsibleState.Expanded,
                    tooltip: aliasesString.length !== 0 
                        ? `${noteNode.noun} (${aliasesString})`
                        : `${noteNode.noun}`,
                    command: editCommand
                }
            case 'description': case 'appearance': return {
                id: `${noteNode.noteId}__${noteNode.idx}__${noteNode.kind}`,
                contextValue: noteNode.kind,
                label: noteNode.description,
                collapsibleState: vscode.TreeItemCollapsibleState.None,
                tooltip: noteNode.description,
                iconPath: new vscode.ThemeIcon("debug-breakpoint-disabled"),
                command: editCommand
            }
            case 'appearanceContainer': return {
                id: `${noteNode.noteId}__appearanceContainer`,
                contextValue: noteNode.kind,
                label: 'Appearance',
                collapsibleState: vscode.TreeItemCollapsibleState.Expanded,
                tooltip: 'Appearance',
                command: editCommand
            }
        }
    }
    getChildren(element?: Note | SubNote | AppearanceContainer | undefined): vscode.ProviderResult<(Note | SubNote | AppearanceContainer)[]> {
        if (!element) return this.notebook;
        switch (element.kind) {
            case 'note': 
                const descriptions: SubNote[] = element.description.map((desc, idx) => ({
                    kind: 'description',
                    idx: idx,
                    noteId: element.noteId,
                    description: desc,
                }));

                const appearances: SubNote[] = element.appearance.map((desc, idx) => ({
                    kind: 'appearance',
                    description: desc,
                    idx: idx,
                    noteId: element.noteId
                }));

                const appearanceContainer: AppearanceContainer = {
                    appearances: appearances,
                    kind: 'appearanceContainer',
                    noteId: element.noteId
                }

                return [
                    appearanceContainer,
                    ...descriptions
                ];
            case 'appearanceContainer': 
                return element.appearances
            case 'description': case 'appearance':
                return [];
        }
    }

    getParent(element: Note | SubNote | AppearanceContainer): vscode.ProviderResult<Note | SubNote | AppearanceContainer> {
        if (element.kind === 'description' || element.kind === 'appearance' || element.kind === 'appearanceContainer') {
            return this.notebook.find(note => note.noteId === element.noteId);
        }
        else if (element.kind === 'note') {
            return null;
        }
        else throw `Not possible`;
    }

    getNote (noteUri: vscode.Uri): Note | null {
        return this.notebook.find(note => {
            const thisUri = note.uri;
            return compareFsPath(thisUri, noteUri);
        }) || null;
    }

    async searchInSearchPanel (resource: Note) {
        vscode.commands.executeCommand('workbench.action.findInFiles', {
            query: this.getNounPattern(resource, false),
            triggerSearch: true,
            filesToInclude: 'data/chapters/**, data/snips/**',
            isRegex: true,
            isCaseSensitive: false,
            matchWholeWord: true,
        });
    }


    provideHover(
        document: vscode.TextDocument, 
        position: vscode.Position, 
        token: vscode.CancellationToken
    ): vscode.ProviderResult<vscode.Hover> {
        if (!this.matchedNotebook) return null;

        const documentMatches = this.matchedNotebook[formatFsPathForCompare(document.uri)];
        if (!documentMatches) return null;

        const matchedNote = documentMatches.find(match => match.range.contains(position));
        if (!matchedNote) return null;
        if (this.view.visible) {
            this.view.reveal(matchedNote.note, {
                select: true,
                expand: true,
            });
        }
        return null;
    }

    provideDefinition (
        document: vscode.TextDocument, 
        position: vscode.Position, 
        token: vscode.CancellationToken
    ): vscode.ProviderResult<vscode.Definition | vscode.LocationLink[]> {
        if (!this.matchedNotebook) return null;

        const documentMatches = this.matchedNotebook[formatFsPathForCompare(document.uri)];
        if (!documentMatches) return null;

        const matchedNote = documentMatches.find(match => match.range.contains(position));
        if (!matchedNote) return null;
    
        if (this.view.visible) {
            this.view.reveal(matchedNote.note, {
                select: true,
                expand: true,
            });
        }
    
        const fileName = `${matchedNote.note.noteId}.wtnote`;
        const filePath = vscode.Uri.joinPath(this.notebookFolderPath, fileName);
        return <vscode.Definition>{
            uri: filePath,
            range: new vscode.Range(position, position),
        };
    }

    async provideReferences(
        document: vscode.TextDocument, 
        position: vscode.Position, 
        context: vscode.ReferenceContext, 
        token: vscode.CancellationToken
    ): Promise<vscode.Location[] | null> {
        if (!this.matchedNotebook) return null;
        
        const documentMatches = this.matchedNotebook[formatFsPathForCompare(document.uri)];
        if (!documentMatches) return null;

        const matchedNote = documentMatches.find(match => match.range.contains(position));
        if (!matchedNote) return null;

        return defaultProgress(`Collecting references for '${matchedNote.note.noun}'`, async () => {
            const subsetNounsRegex = this.getNounsRegex(false, false, [ matchedNote.note ]);
            const grepLocations: vscode.Location[] = []; 
            for await (const loc of grepExtensionDirectory(subsetNounsRegex.source, true, true, true)) {
                if (loc === null) return null;
                grepLocations.push(loc);
            }
    
            // For some reason the reference provider needs the locations to be indexed one less than the results from the 
            //      grep of the nouns
            // Not sure why that is -- but subtracting one from each character index works here
            return grepLocations.map(loc => new vscode.Location(loc.uri, new vscode.Range(
                new vscode.Position(loc.range.start.line, Math.max(loc.range.start.character - 1, 0)),
                new vscode.Position(loc.range.end.line, Math.max(loc.range.end.character - 1, 0))
            )));
        });
    }
}