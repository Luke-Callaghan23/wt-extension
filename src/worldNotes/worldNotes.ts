import * as vscode from 'vscode';
import { Packageable } from '../packageable';
import { readNotes, writeNotes } from './fs';
import { Workspace } from '../workspace/workspaceClass';
import { addAlias, addDescription, addNote, removeAlias, removeDescription, removeNote } from './update';
import { Timed } from '../timedView';
import { disable, update } from './timer';
import { v4 as uuidv4 } from 'uuid';
import { provideHover } from './hoverProvider';

export interface Note {
    kind: 'note';
    noteId: string;
    noun: string;
    aliases: string[];
    descriptions: string[];
}

export interface Description {
    kind: 'description';
    idx: number;
    noteId: string;
    description: string;
}

export interface NoteMatch {
    range: vscode.Range;
    note: Note;
}
export interface UriNoteMatch {
    docUri: vscode.Uri,
    matches: NoteMatch[]
}

export class WorldNotes 
implements 
    vscode.TreeDataProvider<Note | Description>, 
    vscode.HoverProvider,
    Packageable, Timed 
{

    readNotes = readNotes;
    writeNotes = writeNotes;

    addAlias = addAlias;
    removeAlias = removeAlias;
    addNote = addNote;
    removeNote = removeNote;
    addDescription = addDescription;
    removeDescription = removeDescription;

    provideHover = provideHover;
    
    enabled: boolean;
    update = update;
    disable = disable;

    static singleton: WorldNotes;

    public matchedNotes: UriNoteMatch | undefined;
    protected nounsRegex: RegExp | undefined;

    protected notes: Note[];
    protected dontAskDeleteNote: boolean;
    protected dontAskDeleteDescription: boolean;
    protected worldNotesPath: vscode.Uri;
    protected view: vscode.TreeView<Note | Description>;
    constructor (
        protected workspace: Workspace,
        protected context: vscode.ExtensionContext
    ) {
        this.worldNotesPath = workspace.worldNotesPath;
        
        const dontAskDeleteNote: boolean | undefined = context.globalState.get<boolean>('wt.worldNotes.dontAskDeleteNote');
        this.dontAskDeleteNote = dontAskDeleteNote || false;
        
        const dontAskDeleteDescription: boolean | undefined = context.globalState.get<boolean>('wt.worldNotes.dontAskDeleteDescription');
        this.dontAskDeleteDescription = dontAskDeleteDescription || false;

        // Will be modified by TimedView
        this.enabled = true;

        // Read notes from disk
        this.notes = []; 
        this.view = {} as vscode.TreeView<Note | Description>
        this._onDidChangeFile = new vscode.EventEmitter<vscode.FileChangeEvent[]>();
        (async () => { 
            this.notes = await this.readNotes(workspace.worldNotesPath)
            this.nounsRegex = this.getNounsRegex();
            this.view = vscode.window.createTreeView(`wt.worldNotes.tree`, {
                treeDataProvider: this,
                canSelectMany: true,
                showCollapseAll: true,
            });
            vscode.languages.registerHoverProvider({
                language: 'wt'
            }, this);
            this.registerCommands();
        })();
        WorldNotes.singleton = this;
    }

    static getNewNoteId (): string {
        // Default id generated by 'uuid' cannot be used as a capture group name,
        //      so we need to map them to something usable
        const id = uuidv4();
        const mappedId = id.replaceAll('-', '');            // remove dashes
        return `a${mappedId}`;                              // add an 'a' to the beginning
    }

	public _onDidChangeFile: vscode.EventEmitter<vscode.FileChangeEvent[]>;
	get onDidChangeFile(): vscode.Event<vscode.FileChangeEvent[]> {
		return this._onDidChangeFile.event;
	}

	private _onDidChangeTreeData: vscode.EventEmitter<Note | Description | undefined> = new vscode.EventEmitter<Note | Description | undefined>();
	readonly onDidChangeTreeData: vscode.Event<Note | Description | undefined> = this._onDidChangeTreeData.event;
	refresh () {
        // Also update the nouns regex
        this.nounsRegex = this.getNounsRegex();
		this._onDidChangeTreeData.fire(undefined);
	}

    private getNounsRegex () {
        const nounFragments = this.notes.map(note => {
            const aliasesAddition = note.aliases.length > 0 
                ? `|${note.aliases.join('|')}`
                : ``;
            return `(?<${note.noteId}>${note.noun}${aliasesAddition})`
        })
        const regexString = nounFragments.join('|');
        const nounsRegex = new RegExp(regexString, 'gi');
        return nounsRegex;
    }

    private registerCommands () {
        vscode.commands.registerCommand("wt.worldNotes.addAlias", (resource: Note) => { this.addAlias(resource) });
        vscode.commands.registerCommand("wt.worldNotes.removeAlias", (resource: Note) => { this.removeAlias(resource) });
        vscode.commands.registerCommand("wt.worldNotes.addNote", (resource: Note | undefined) => { this.addNote(resource) });
        vscode.commands.registerCommand("wt.worldNotes.removeNote", (resource: Note) => { this.removeNote(resource) });
        vscode.commands.registerCommand("wt.worldNotes.addDescription", (resource: Description) => { this.addDescription(resource) });
        vscode.commands.registerCommand("wt.worldNotes.removeDescription", (resource: Description) => { this.removeDescription(resource) });
    }

    getPackageItems(): { [index: string]: any; } {
        return {};
    }


    getTreeItem(noteNode: Note | Description): vscode.TreeItem | Thenable<vscode.TreeItem> {
        switch (noteNode.kind) {
            case 'note': 
                const aliasesString = noteNode.aliases.join(', ');
                return {
                    id: noteNode.noteId,
                    contextValue: 'note',
                    label: noteNode.noun,
                    description: aliasesString,
                    collapsibleState: vscode.TreeItemCollapsibleState.Expanded,
                    tooltip: aliasesString.length !== 0 
                        ? `${noteNode.noun} (${aliasesString})`
                        : `${noteNode.noun}`,
                }
            case 'description': return {
                id: `${noteNode.noteId}__${noteNode.idx}`,
                contextValue: 'description',
                label: noteNode.description,
                collapsibleState: vscode.TreeItemCollapsibleState.None,
                tooltip: noteNode.description,
                iconPath: new vscode.ThemeIcon("debug-breakpoint-disabled")
            }
        }
    }
    getChildren(element?: Note | Description | undefined): vscode.ProviderResult<(Note | Description)[]> {
        if (!element) return this.notes;
        switch (element.kind) {
            case 'note': 
                return element.descriptions.map((desc, idx) => ({
                    kind: 'description',
                    idx: idx,
                    noteId: element.noteId,
                    description: desc,
                }));
            case 'description': return [];
        }
    }
}